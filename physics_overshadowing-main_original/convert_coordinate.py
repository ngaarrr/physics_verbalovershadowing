"""
Convert an (x, y) coordinate generated by the engine the matching one on
Unity 3D scene.
"""
import numpy as np 

CONVERSION_CAM_PROJ_MATRIX = np.array([[1.44338, 0.0, 0.0, 0.0],
									   [0.0, 1.73205, 0.0, 0.0],
									   [0.0, 0.0, -1.0006, -0.60018],
									   [0.0, 0.0, -1.0, 0.0]])
CONVERSION_CAM_WORLD_2_CAM_MATRIX = np.array([[-1.0, 0.0, 0.0, 0.0],
											  [0.0, 1.0, 0.0, 0.0],
											  [0.0, 0.0, 1.0, -1.03],
											  [0.0, 0.0, 0.0, 1.0]])
CONVERSION_CAM_LOCAL_2_WORLD_MATRIX = np.array([[-1.0, 0.0, 0.0, 0.0],
												[0.0, 1.0, 0.0, 0.0],
												[0.0, 0.0, -1.0, 1.03],
												[0.0, 0.0, 0.0, 1.0]])

RENDER_CAM_PROJECTION_MATRIX = np.array([[2.643, 0.0, 0.0, 0.0],
										 [0.0, 3.1716, 0.0, 0.0],
										 [0.0, 0.0, -1.0006, -0.60018],
										 [0.0, 0.0, -1.0, 0.0]])
RENDER_CAM_WORLD_2_CAM_MATRIX = np.array([[-1.0, 0.0, 0.0, 0.0],
										  [0.0, 1.0, 0.0, 0.0],
										  [0.0, 0.0, 1.0, -2.14],
										  [0.0, 0.0, 0.0, 1.0]])

WIDTH = 600.0
HEIGHT = 500.0
OFFSET_X = 50
OFFSET_Y = 100

def convertCoordinate(x, y):

	orig_point = np.array([x-OFFSET_X, y-OFFSET_Y, 1.0])
	world_point = screen2WorldPoint(CONVERSION_CAM_PROJ_MATRIX, CONVERSION_CAM_WORLD_2_CAM_MATRIX, 
									CONVERSION_CAM_LOCAL_2_WORLD_MATRIX, WIDTH, HEIGHT, orig_point)
	screen_point = world2ScreenPoint(RENDER_CAM_PROJECTION_MATRIX, RENDER_CAM_WORLD_2_CAM_MATRIX,
									 WIDTH, HEIGHT, world_point)
	return (screen_point[0], screen_point[1])



def world2ScreenPoint(projection_matrix, world_2_cam_matrix, width, height, world_point):
	"""
	Convert a world point to a point on screen.
	projection_matrix: 4x4 matrix obtained by cam.projectionMatrix
	world_2_cam_matrix: 4x4 matrix obtained by cam.worldToCameraMatrix
	world_point: 3d vector representing a point in world
	"""
	world2screen = np.matmul(projection_matrix, world_2_cam_matrix)

	# print(world_point)

	screen_point = np.matmul(world2screen, _3d_to_4d_vector(world_point))
	

	# (-1, 1)'s clip  => (0, 1)'s viewport
	x = (screen_point[0]/screen_point[3] + 1.0) / 2.0
	y = (screen_point[1]/screen_point[3] + 1.0) / 2.0

	# viewport => screen
	x = x * width
	y = y * height
	# print(x)
	return np.array([x, y])


def invertWorld2ScreenPoint(screen_point, width, height):

	x = screen_point[0]/width
	y = screen_point[1]/height

	x = x*2



def screen2WorldPoint(projection_matrix, world_2_cam_matrix, local_2_world_matrix, wdith, height, screen_point):
	"""
	Convert a screen point to a world point.
	projection_matrix: 4x4 matrix obtained by cam.projectionMatrix
	world_2_cam_matrix: 4x4 matrix obtained by cam.worldToCameraMatrix
	screen_point: 2d vector representing a point in world
	"""
	world2screen = np.matmul(np.matmul(projection_matrix, world_2_cam_matrix),local_2_world_matrix)
	screen2world = np.linalg.inv(np.matmul(projection_matrix, world_2_cam_matrix))
	
	depth = np.matmul(world2screen, _2d_to_4d_vector(screen_point))[2]

	# viewport pos (0 ,1)
	view_point = np.array([screen_point[0]/wdith, screen_point[1]/height, (depth + 1.0)/2.0])

	# clip pos (-1, 1)
	clip_point = view_point * 2.0 - np.array([1.0, 1.0, 1.0])

	world_point = np.matmul(screen2world, _3d_to_4d_vector(clip_point))

	return world_point[:3]

def _2d_to_4d_vector(vec):
	"""
	Append 1.0 to the end of input 2d vector.
	"""
	return np.array([vec[0], vec[1], 1.0, 1.0])

def _3d_to_4d_vector(vec):
	"""
	Append 1.0 to the end of input 3d vector.
	"""
	return np.array([vec[0], vec[1], vec[2], 1.0])
